The problem is that a page showing "Categories" doesn't have access to the completion dates of the subtopics within those categories, so it can't draw an accurate graph.

Here is a comprehensive API and backend logic suggestion to fix this for all three pages, ensuring your charts are consistent and reflect the real, incremental progress from your database.

## The Solution: A Single, Comprehensive API Endpoint
Instead of having multiple endpoints that return partial data, the most efficient solution is to have one primary endpoint that fetches all the necessary nested data for your dashboard views. We can modify your existing GET /api/goals route to serve this purpose.

This endpoint will return the full data structure, and the frontend will simply filter and display the relevant parts on each page.

1. Update the API Response Structure
Your GET /api/goals endpoint should return an array of Goal objects, but each object must be enriched with the aggregated completedSubtopicTimestamps at every level.

Required JSON Output from GET /api/goals:

JSON

[
  {
    "id": "goal-id-tnpsc",
    "name": "tnpsc",
    "completedSubtopics": 7,
    "totalSubtopics": 111,
    "completedSubtopicTimestamps": [ 
        "2025-08-27T13:46:35.216Z",
        "2025-08-27T15:21:34.685Z",
        "..." 
    ],
    "categories": [
      {
        "id": "category-id-part-a",
        "name": "Part A: General Studies",
        "completedSubtopics": 6,
        "completedSubtopicTimestamps": [
            "2025-08-27T13:46:35.216Z",
            "..."
        ],
        "topics": [
          {
            "id": "topic-id-gen-sci",
            "name": "Unit 1: General Science",
            "completedSubtopics": 2,
            "completedSubtopicTimestamps": [
                "2025-08-27T13:46:35.216Z",
                "2025-08-27T13:46:36.441Z"
            ]
          }
        ]
      }
    ]
  }
]
2. Update Your Backend storage.ts Logic
To produce this data structure, you need to modify your getUserGoalsWithCategories function in storage.ts. This function will now perform the necessary joins and aggregations to collect the timestamps.

Here is the suggested implementation for that function:

TypeScript

// Inside storage.ts

// ... other code

  async getUserGoalsWithCategories(userId: number): Promise<any[]> {
    // 1. Fetch the user's top-level goals
    const userGoals = await db.select().from(goals).where(eq(goals.userId, userId));

    // 2. For each goal, recursively fetch and aggregate data for its children
    const detailedGoals = await Promise.all(
      userGoals.map(async (goal) => {
        
        const categories = await db.select().from(goalCategories).where(eq(goalCategories.goalId, goal.id));
        
        let goalCompletedTimestamps: string[] = [];

        const detailedCategories = await Promise.all(
          categories.map(async (category) => {
            
            const topics = await db.select().from(goalTopics).where(eq(goalTopics.categoryId, category.id));
            
            let categoryCompletedTimestamps: string[] = [];

            const detailedTopics = await Promise.all(
              topics.map(async (topic) => {
                
                // Fetch subtopics and their completion dates
                const subtopics = await db.select({
                    status: goalSubtopics.status,
                    completedAt: goalSubtopics.completedAt
                  })
                  .from(goalSubtopics)
                  .where(eq(goalSubtopics.topicId, topic.id));

                const completedSubtopics = subtopics.filter(s => s.status === 'completed');
                
                const topicCompletedTimestamps = completedSubtopics
                  .map(s => s.completedAt ? s.completedAt.toISOString() : null)
                  .filter((ts): ts is string => ts !== null);
                
                // Add this topic's timestamps to the category's list
                categoryCompletedTimestamps.push(...topicCompletedTimestamps);

                return {
                  ...topic,
                  totalSubtopics: subtopics.length,
                  completedSubtopics: completedSubtopics.length,
                  completedSubtopicTimestamps: topicCompletedTimestamps,
                };
              })
            );

            const categoryTotalSubtopics = detailedTopics.reduce((sum, t) => sum + t.totalSubtopics, 0);
            const categoryCompletedSubtopics = detailedTopics.reduce((sum, t) => sum + t.completedSubtopics, 0);

            // Add this category's timestamps to the goal's list
            goalCompletedTimestamps.push(...categoryCompletedTimestamps);

            return {
              ...category,
              totalSubtopics: categoryTotalSubtopics,
              completedSubtopics: categoryCompletedSubtopics,
              completedSubtopicTimestamps: categoryCompletedTimestamps,
              topics: detailedTopics,
            };
          })
        );

        const goalTotalSubtopics = detailedCategories.reduce((sum, c) => sum + c.totalSubtopics, 0);
        const goalCompletedSubtopics = detailedCategories.reduce((sum, c) => sum + c.completedSubtopics, 0);

        return {
          ...goal,
          totalSubtopics: goalTotalSubtopics,
          completedSubtopics: goalCompletedSubtopics,
          completedSubtopicTimestamps: goalCompletedTimestamps,
          categories: detailedCategories,
        };
      })
    );

    return detailedGoals;
  }

// ... other code
3. How the Frontend Uses the New API Data
With this single, powerful data source, your frontend pages become much simpler.

GoalStart.tsx (Main Dashboard):

It fetches data from GET /api/goals.

It passes the entire goals array to the ApexProgressChart.

The chart component maps through goals and uses goal.completedSubtopicTimestamps for each series.

GoalTracker.tsx (Category View):

It also fetches data from GET /api/goals.

It finds the specific goal the user clicked on from the fetched data.

It passes that goal.categories array to its ApexProgressChart.

The chart then maps through the categories and uses category.completedSubtopicTimestamps.

CategoryTopics.tsx (Topic View):

It also fetches data from GET /api/goals.

It finds the specific goal and then the specific category the user is viewing.

It passes that category.topics array to its ApexTopicProgressChart.

The chart maps through the topics and uses the real topic.completedSubtopicTimestamps.

This approach eliminates data inconsistencies and ensures that every chart, at every level, is a true and accurate representation of your database records.